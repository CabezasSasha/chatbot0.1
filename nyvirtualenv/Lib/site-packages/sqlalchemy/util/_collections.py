# util/_collections.py
# Copyright (C) 2005-2019 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""Collection classes and helpers."""

from __future__ import absolute_import

import operator
import types
import weakref

from .compat import binary_types
from .compat import collections_abc
from .compat import itertools_filterfalse
from .compat import py2k
from .compat import string_types
from .compat import threading


EMPTY_SET = frozenset()


class AbstractKeyedTuple(tuple):
    __slots__ = ()

    def keys(self):
        """Devuelve una lista de nombres de clave de esta :clase:`.KeyedTuple`.

        .. seealso::

            :attr:`.KeyedTuple._fields`

        """

        return list(self._fields)


class KeyedTuple(AbstractKeyedTuple):
    """Subclase de ``tuple`` que agrega nombres etiquetados.

    Ejemplo::

        >>> k = KeyedTuple([1, 2, 3], labels=["uno", "dos", "tres"])
        >>> k.uno
        1
        >>> k.dos
        2

    Las filas de resultados devueltas por :clase:`.Query` que contienen múltiples
    entidades ORM y/o expresiones de columna hacen uso de esta
    clase para devolver filas.

    :clase:`.KeyedTuple` muestra un comportamiento similar al
    constructo ``collections.namedtuple()`` proporcionado en la biblioteca estándar de Python,
    sin embargo, está arquitecturado de manera muy diferente.
    A diferencia de ``collections.namedtuple()``, :clase:`.KeyedTuple` no se
    confía en la creación de subtipos personalizados para representar
    una nueva serie de claves, en su lugar, cada instancia de :clase:`.KeyedTuple`
    recibe su lista de claves en su lugar. El enfoque de subtipo
    de ``collections.namedtuple()`` introduce una complejidad significativa
    y sobrecarga de rendimiento, lo cual no es necesario para el
    caso de uso del objeto :clase:`.Query`.

    .. seealso::

        :ref:`ormtutorial_querying`

    """

    def __new__(cls, vals, labels=None):
        t = tuple.__new__(cls, vals)
        if labels:
            t.__dict__.update(zip(labels, vals))
        else:
            labels = []
        t.__dict__["_labels"] = labels
        return t

    @property
    def _fields(self):
        """Devuelve una tupla de nombres de clave de esta :clase:`.KeyedTuple`.

        Este método proporciona compatibilidad con ``collections.namedtuple()``.

        .. seealso::

            :meth:`.KeyedTuple.keys`

        """
        return tuple([l for l in self._labels if l is not None])

    def __setattr__(self, key, value):
        raise AttributeError("No se puede establecer el atributo: %s" % key)

    def _asdict(self):
        """Devuelve el contenido de esta :clase:`.KeyedTuple` como un diccionario.

        Este método proporciona compatibilidad con ``collections.namedtuple()``,
        con la excepción de que el diccionario devuelto **no** está ordenado.

        """
        return {key: self.__dict__[key] for key in self.keys()}


class _LW(AbstractKeyedTuple):
    __slots__ = ()

    def __new__(cls, vals):
        return tuple.__new__(cls, vals)

    def __reduce__(self):
        # para hacer pickle, se degrada a la versión regular
        return (tuple, tuple(self))

    def __bool__(self):
        return bool(self._asdict())

    def __repr__(self):
        return "<%s at 0x%x: %s>" % (
            self.__class__.__name__,
            id(self),
            self._asdict(),
        )

    def __getstate__(self):
        # Hace pickable este objeto
        return tuple(self)

    def __setstate__(self, state):
        self.__dict__.update(zip(self._fields, state))


class ImmutableContainer(object):
    """Establece la directiva :keyword:`class`.

    Los subclases de :clase:`.ImmutableContainer` no pueden modificar ningún
    atributo; una vez que están configurados, no se pueden modificar.

    """

    __slots__ = ()

    def __init__(self):
        raise TypeError(
            "%r no se puede inicializar; los atributos son de solo lectura"
            % self.__class__.__name__
        )

    def __setattr__(self, key, value):
        raise TypeError(
            "%r no se puede establecer el atributo: %s"
            % (self.__class__.__name__, key)
        )

    def __delattr__(self, key):
        raise TypeError(
            "%r no se puede eliminar el atributo: %s"
            % (self.__class__.__name__, key)
        )


class immutabledict(ImmutableContainer, dict):
    """Diccionario inmutable.

    .. seealso::

        :class:`.ImmutableProperties`

    """

    def clear(self):
        raise TypeError("Los objetos %s no admiten 'clear()'" % self.__class__.__name__)

    def pop(self, *arg):
        raise TypeError("Los objetos %s no admiten 'pop()'" % self.__class__.__name__)

    def popitem(self):
        raise TypeError("Los objetos %s no admiten 'popitem()'" % self.__class__.__name__)

    def setdefault(self, *arg):
        raise TypeError("Los objetos %s no admiten 'setdefault()'" % self.__class__.__name__)

    def update(self, *arg):
        raise TypeError("Los objetos %s no admiten 'update()'" % self.__class__.__name__)


class Properties(ImmutableContainer):
    """El acceso a diccionarios como atributos.

    Permite el acceso a través de ``obj.x`` en lugar de ``obj['x']``.

    """

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(key)

    def __setstate__(self, state):
        # Convierte el estado a inmutable
        ImmutableContainer.__setstate__(self, state)


class OrderedProperties(Properties):
    """El acceso a diccionarios ordenados como atributos.

    Similar a :class:`.Properties`, pero mantiene el orden de las claves.

    .. seealso::

        :class:`.Properties`

    """

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def __iter__(self):
        return iter(self.__dict__)

    def keys(self):
        return list(self.__dict__)

    def values(self):
        return list(self.__dict__.values())

    def items(self):
        return list(self.__dict__.items())


    class ImmutableProperties(Properties, ImmutableContainer):
      """El acceso a diccionarios inmutables como atributos.

      Similar a :class:`.Properties`, pero los atributos no se pueden cambiar después
      de la inicialización.

     .. seealso::

        :class:`.Properties`
        :class:`.ImmutableContainer`

    """
