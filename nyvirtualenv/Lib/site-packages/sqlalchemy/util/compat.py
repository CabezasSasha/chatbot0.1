# util/compat.py
# Copyright (C) 2005-2019 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""Handle Python version/platform incompatibilities."""
import base64
import collections
import configparser
import sys
import threading
import time
import asyncio
from collections import namedtuple
from contextlib import contextmanager
from operator import attrgetter as dottedgetter
from types import FunctionType
from urllib.parse import quote_plus, unquote_plus, parse_qsl, quote, unquote
from inspect import getfullargspec, formatannotation
from io import StringIO, BytesIO as byte_buffer
from functools import reduce
from itertools import zip_longest

py36 = sys.version_info >= (3, 6)
py33 = sys.version_info >= (3, 3)
py35 = sys.version_info >= (3, 5)
py32 = sys.version_info >= (3, 2)
py3k = sys.version_info >= (3, 0)
py2k = sys.version_info < (3, 0)
py265 = sys.version_info >= (2, 6, 5)
jython = sys.platform.startswith("java")
pypy = hasattr(sys, "pypy_version_info")
win32 = sys.platform.startswith("win")
cpython = not pypy and not jython

next = next

if py3k:
    import pickle
else:
    try:
        import pickle as pickle
    except ImportError:
        import pickle

if py265:
    safe_kwarg = lambda arg: arg
else:
    safe_kwarg = str

ArgSpec = collections.namedtuple("ArgSpec", ["args", "varargs", "keywords", "defaults"])

if py3k:
    import builtins

    string_types = (str,)
    binary_types = (bytes,)
    binary_type = bytes
    text_type = str
    int_types = (int,)

    def iterbytes(buf):
        return (ord(byte) for byte in buf)

    def u(s):
        return s

    def ue(s):
        return s

    def b(s):
        return s

    if py32:
        callable = callable
    else:
        def callable(fn):
            return hasattr(fn, "__call__")

    def decode_backslashreplace(text, encoding):
        return text.decode(encoding, errors="backslashreplace")

    def cmp(a, b):
        return (a > b) - (a < b)

    print_ = getattr(builtins, "print")

    import_ = getattr(builtins, "__import__")

    import itertools

    itertools_filterfalse = itertools.filterfalse
    itertools_filter = filter
    itertools_imap = map

    import base64

    def b64encode(x):
        return base64.b64encode(x).decode("ascii")

    def b64decode(x):
        return base64.b64decode(x.encode("ascii"))

if py3k:
    from inspect import getfullargspec
    argspec = getfullargspec(FunctionType)

    inspect_getargspec = getfullargspec
    from urllib.parse import quote_plus, unquote_plus, quote, unquote
    from urllib.parse import parse_qsl
    import configparser as configparser
    from io import StringIO, BytesIO as byte_buffer

    string_types = (str,)
    binary_types = (bytes,)
    binary_type = str
    text_type = str
    int_types = (int,)

    def iterbytes(buf):
        return (ord(byte) for byte in buf)

    def u(s):
        return s

    def ue(s):
        return s

    def b(s):
        return s

    def import_(*args):
        if len(args) == 4:
            args = args[0:3] + ([str(arg) for arg in args[3]],)
        return __import__(*args)

    callable = callable
    cmp = cmp
    reduce = reduce

    import base64

    b64encode = base64.b64encode
    b64decode = base64.b64decode

    def print_(*args, **kwargs):
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return
        for arg in enumerate(args):
            if not isinstance(arg, str):
                arg = str(arg)
            fp.write(arg)

    import itertools

    def decode_backslashreplace(text, encoding):
        try:
            return text.decode(encoding)
        except UnicodeDecodeError:
            return repr(text)[1:-1].decode()

    itertools_filterfalse = itertools.filterfalse
    itertools_filter = filter
    itertools_imap = map
    zip_longest = itertools.zip_longest

if py35:
    def inspect_formatargspec(
        args,
        varargs=None,
        varkw=None,
        defaults=None,
        kwonlyargs=(),
        kwonlydefaults={},
        annotations={},
        formatarg=str,
        formatvarargs=lambda name: "*" + name,
        formatvarkw=lambda name: "**" + name,
        formatvalue=lambda value: "=" + repr(value),
        formatreturns=lambda text: " -> " + text,
        formatannotation=formatannotation,
    ):
        def formatargandannotation(arg):
            result = formatarg(arg)
            if arg in annotations:
                result += ": " + formatannotation(annotations[arg])
            return result

        specs = []
        if defaults:
            firstdefault = len(args) - len(defaults)
        for i, arg in enumerate(args):
            spec = formatargandannotation(arg)
            if defaults and i >= firstdefault:
                spec = spec + formatvalue(defaults[i - firstdefault])
            specs.append(spec)
        if varargs is not None:
            specs.append(formatvarargs(formatargandannotation(varargs)))
        else:
            if kwonlyargs:
                specs.append("*")
        if kwonlyargs:
            for kwonlyarg in kwonlyargs:
                spec = formatargandannotation(kwonlyarg)
                if kwonlydefaults and kwonlyarg in kwonlydefaults:
                    spec += formatvalue(kwonlydefaults[kwonlyarg])
                specs.append(spec)
